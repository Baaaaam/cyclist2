{
 "annotations": {
  ":agents:KFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility designed for integration tests that both provides and consumes commodities. It changes its request and offer amounts based on a power law with respect to time.", 
   "entity": "facility", 
   "name": "cyclus::KFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "current_capacity": {
     "default": 0, 
     "doc": "number of output commodity units that can be supplied at the current time step (infinite capacity can be represented by a very large number", 
     "index": 5, 
     "tooltip": "current output capacity", 
     "type": "double"
    }, 
    "in_capacity": {
     "doc": "number of commodity units that can be taken at each time step (infinite capacity can be represented by a very large number", 
     "index": 3, 
     "tooltip": "input commodity capacity", 
     "type": "double"
    }, 
    "in_commod": {
     "doc": "commodity that the k-facility consumes", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "input commodity", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 7, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "k_factor_in": {
     "doc": "conversion factor that governs the behavior of the k-facility's input commodity capacity", 
     "index": 8, 
     "tooltip": "input k-factor", 
     "type": "double"
    }, 
    "k_factor_out": {
     "doc": "conversion factor that governs the behavior of the k-facility's output commodity capacity", 
     "index": 9, 
     "tooltip": "output k-factor", 
     "type": "double"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of the k-facility", 
     "index": 6, 
     "tooltip": "k-facility maximum inventory size", 
     "type": "double"
    }, 
    "out_capacity": {
     "doc": "number of commodity units that can be supplied at each time step (infinite capacity can be represented by a very large number", 
     "index": 4, 
     "tooltip": "output commodity capacity", 
     "type": "double"
    }, 
    "out_commod": {
     "doc": "commodity that the k-facility supplies", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "output commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "doc": "recipe name for the k-facility's in-commodity", 
     "index": 2, 
     "schematype": "token", 
     "shape": [50], 
     "tooltip": "in-commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  ":agents:NullInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "An instition that owns facilities in the simulation but exhibits null behavior. No parameters are given when using the null institution.", 
   "entity": "institution", 
   "name": "cyclus::NullInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  ":agents:NullRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A region that owns the simulation's institutions but exhibits null behavior. No parameters are given when using the null region.", 
   "entity": "region", 
   "name": "cyclus::NullRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }, 
  ":agents:Predator": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents predators in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Predator", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of predator at beginning of simulation", 
     "index": 7, 
     "tooltip": "predator age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 0, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 11, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "commod": {
     "doc": "commodity that the predator supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "predator commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "consumed": {
     "default": 0, 
     "doc": "how many units of prey consumed per time step", 
     "index": 12, 
     "tooltip": "prey consumed", 
     "type": "double"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether predator is currently dead", 
     "index": 9, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "full": {
     "default": 1, 
     "doc": "how many units of prey a predator consumes until it is satisfied", 
     "index": 2, 
     "tooltip": "feast size", 
     "type": "double"
    }, 
    "hunt_cap": {
     "default": 1, 
     "doc": "how many units of prey a predator can catch during a hunt", 
     "index": 3, 
     "tooltip": "hunting yield", 
     "type": "double"
    }, 
    "hunt_factor": {
     "default": 0, 
     "doc": "whether or not to base hunting success on relative predator/prey populations", 
     "index": 10, 
     "tooltip": "hunting success factor", 
     "type": "bool"
    }, 
    "hunt_freq": {
     "default": 1, 
     "doc": "how often a predator needs to hunt", 
     "index": 4, 
     "tooltip": "hunting frequency", 
     "type": "int"
    }, 
    "lifespan": {
     "default": 1, 
     "doc": "how long a predator lives", 
     "index": 8, 
     "tooltip": "predator lifespan", 
     "type": "int"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of predator children born at each birthing instance", 
     "index": 6, 
     "tooltip": "number of children", 
     "type": "double"
    }, 
    "prey": {
     "doc": "prey that the predator hunts", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "predator's prey", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "success": {
     "default": 1, 
     "doc": "fraction of hunting success on a scale from 0 to 1", 
     "index": 5, 
     "tooltip": "hunting success fraction", 
     "type": "double"
    }
   }
  }, 
  ":agents:Prey": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents prey in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Prey", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of prey at start of simulation", 
     "index": 3, 
     "tooltip": "prey age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 1, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 5, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "birth_freq": {
     "default": 1, 
     "doc": "number of time steps between birth of children", 
     "index": 1, 
     "tooltip": "birth frequency", 
     "type": "int"
    }, 
    "commod": {
     "index": 0, 
     "schematype": "token", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether prey is currently dead", 
     "index": 4, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of children born at each birthing instance", 
     "index": 2, 
     "tooltip": "number of children", 
     "type": "int"
    }
   }
  }, 
  ":agents:Sink": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation sink facility that accepts specified amounts of commodities from other agents", 
   "entity": "facility", 
   "name": "cyclus::Sink", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "capacity the sink facility can accept at each time step", 
     "index": 2, 
     "tooltip": "sink capacity", 
     "type": "double"
    }, 
    "in_commods": {
     "doc": "commodities that the sink facility accepts", 
     "index": 1, 
     "tooltip": "input commodities for the sink", 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 4, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of sink facility", 
     "index": 3, 
     "tooltip": "sink maximum inventory size", 
     "type": "double"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Name of recipe to request.If empty, sink requests material no particular composition.", 
     "index": 0, 
     "tooltip": "input/request recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  ":agents:Source": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation source facility that provides a commodity with a given capacity", 
   "entity": "facility", 
   "name": "cyclus::Source", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "amount of commodity that can be supplied at each time step", 
     "index": 2, 
     "tooltip": "source capacity", 
     "type": "double"
    }, 
    "commod": {
     "doc": "commodity that the source facility supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "source commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Recipe name for source facility's commodity.If empty, source supplies material with requested compositions.", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  ":cycamore:DeployInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "Builds and manages agents (facilities) according to a manually specified deployment schedule. Deployed agents are automatically decommissioned at the end of their lifetime.  The user specifies a list of prototypes for each and corresponding build times, number to build, and (optionally) lifetimes.  The same prototype can be specified multiple times with any combination of the same or different build times, build number, and lifetimes. ", 
   "entity": "institution", 
   "name": "cycamore::DeployInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {
    "build_times": {
     "doc": "Time step on which to build agents given in prototypes (same order).", 
     "index": 1, 
     "type": ["std::vector", "int"]
    }, 
    "lifetimes": {
     "default": [], 
     "doc": "Lifetimes for each prototype in protos (same order). These lifetimes override the lifetimes in the original prototype definition. If unspecified, lifetimes from the original prototype definitions are used. Although a new prototype is created in the Prototypes table for each lifetime with the suffix '_life_[lifetime]', all deployed agents themselves will have the same original prototype name (and so will the Agents tables).", 
     "index": 3, 
     "type": ["std::vector", "int"]
    }, 
    "n_build": {
     "doc": "Number of each prototype in prototypes var to build (same order).", 
     "index": 2, 
     "type": ["std::vector", "int"]
    }, 
    "prototypes": {
     "doc": "Ordered list of prototypes to build.", 
     "index": 0, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "prototype"]
    }
   }
  }, 
  ":cycamore:Enrichment": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "The Enrichment facilityis a simple Agent that enriches naturaluranium in a Cyclus simulation. It does not explicitly computethe physical enrichment process, rather it calculates the SWUrequired to convert an source uranium recipe (ie. natural uranium)into a requested enriched recipe (ie. 4% enriched uranium), giventhe natural uranium inventory constraint and its SWU capacityconstraint.\n\nThe Enrichment facility requests an input commodity and associated recipewhose quantity is its remaining inventory capacity.  All facilitiestrading the same input commodity (even with different recipes) willoffer materials for trade.  The Enrichment facility accepts any inputmaterials with enrichments less than its tails assay, as long as someU235 is present, and preference increases with U235 content.  If noU235 is present in the offered material, the trade preference is setto -1 and the material is not accepted.  Any material components otherother than U235 and U238 are sent directly to the tails buffer.\n\nThe Enrichment facility will bid on any request for its output commodityup to the maximum allowed enrichment (if not specified, default is 100%)It bids on either the request quantity, or the maximum quanity allowedby its SWU constraint or natural uranium inventory, whichever is lower.If multiple output commodities with different enrichment levels arerequested and the facility does not have the SWU or quantity capacityto meet all requests, the requests are fully, then partially filledin unspecified but repeatable order.\n\nAccumulated tails inventory is offered for trading as a specifiable output commodity.", 
   "entity": "facility", 
   "name": "cycamore::Enrichment", 
   "niche": "enrichment facility", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "feed_commod": {
     "doc": "feed commodity that the enrichment facility accepts", 
     "index": 0, 
     "tooltip": "feed commodity", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "feed_recipe": {
     "doc": "recipe for enrichment facility feed commodity", 
     "index": 2, 
     "tooltip": "feed recipe", 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "initial_feed": {
     "default": 0, 
     "doc": "amount of natural uranium stored at the enrichment facility at the beginning of the simulation (kg)", 
     "index": 8, 
     "tooltip": "initial uranium reserves (kg)", 
     "type": "double"
    }, 
    "inventory": {
     "capacity": "max_feed_inventory", 
     "index": 10, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "max_enrich": {
     "default": 1.0, 
     "doc": "maximum allowed weight fraction of U235 in product", 
     "index": 7, 
     "schema": "<optional>          <element name=\"max_enrich\">              <data type=\"double\">                  <param name=\"minInclusive\">0</param>                  <param name=\"maxInclusive\">1</param>              </data>          </element>      </optional>", 
     "tooltip": "maximum allowed enrichment fraction", 
     "type": "double"
    }, 
    "max_feed_inventory": {
     "default": 1.000000000000000e+299, 
     "doc": "maximum total inventory of natural uranium in the enrichment facility (kg)", 
     "index": 6, 
     "tooltip": "max inventory of feed material (kg)", 
     "type": "double"
    }, 
    "order_prefs": {
     "default": 1, 
     "doc": "turn on preference ordering for input material so that EF chooses higher U235 content first", 
     "index": 9, 
     "tooltip": "order material requests by U235 content", 
     "type": "bool", 
     "userlevel": 10
    }, 
    "product_commod": {
     "doc": "product commodity that the enrichment facility generates", 
     "index": 1, 
     "tooltip": "product commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "swu_capacity": {
     "default": 1.000000000000000e+299, 
     "doc": "separative work unit (SWU) capacity of enrichment facility (kgSWU/month) ", 
     "index": 5, 
     "tooltip": "SWU capacity (kgSWU/month)", 
     "type": "double"
    }, 
    "tails": {"index": 11, "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]}, 
    "tails_assay": {
     "default": 0.030, 
     "doc": "tails assay from the enrichment process", 
     "index": 4, 
     "tooltip": "tails assay", 
     "type": "double"
    }, 
    "tails_commod": {
     "doc": "tails commodity supplied by enrichment facility", 
     "index": 3, 
     "tooltip": "tails commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }
   }
  }, 
  ":cycamore:FuelFab": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "FuelFab takes in 2 streams of material and mixes them in ratios in order to supply material that matches some neutronics properties of reqeusted material.  It uses an equivalence type method [1] inspired by a similar approach in the COSI fuel cycle simulator.\n\nThe FuelFab has 3 input inventories: fissile stream, filler stream, and an optional top-up inventory.  All materials received into each inventory are always combined into a single material (i.e. a single fissile material, a single filler material, etc.).  The input streams and requested fuel composition are each assigned weights based on summing:\n\n    N * (p_i - p_U238) / (p_Pu239 - p_U238)\n\nfor each nuclide where:\n\n    - p = nu*sigma_f - sigma_a   for the nuclide\n    - p_U238 is p for pure U238\n    - p_Pu239 is p for pure Pu239\n    - N is the nuclide's atom fraction\n    - nu is the average # neutrons per fission\n    - sigma_f is the microscopic fission cross-section\n    - sigma_a is the microscopic neutron absorption cross-section\n\nThe cross sections are from the simple cross section library in PyNE. They can be set to either a thermal or fast neutron spectrum.  A linear interpolation is performed using the weights of the fissile, filler, and target streams. The interpolation is used to compute a mixing ratio of the input streams that matches the target weight.  In the event that the target weight is higher than the fissile stream weight, the FuelFab will attempt to use the top-up and fissile input streams together instead of the fissile and filler streams.  All supplied material will always have the same weight as the requested material.\n\nThe supplying of mixed material is constrained by available inventory quantities and a per time step throughput limit.  Requests for fuel material larger than the throughput can never be met.  Fissile inventory can be requested/received via one or more commodities.  The DRE request preference for each of these commodities can also optionally be specified. By default, the top-up inventory size is zero, and it is not used for mixing. \n\n[1] Baker, A. R., and R. W. Ross. \"Comparison of the value of plutonium and    uranium isotopes in fast reactors.\" Proceedings of the Conference on    Breeding. Economics, and Safety in Large Fast Power Reactors. 1963.", 
   "entity": "facility", 
   "name": "cycamore::FuelFab", 
   "niche": "fabrication", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "fill": {
     "capacity": "fill_size", 
     "index": 4, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "fill_commod": {
     "doc": "Commodity on which to request material for filler stream.", 
     "index": 0, 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "fill_pref": {
     "default": 0, 
     "doc": "Filler material stream request preference.", 
     "index": 2, 
     "type": "double"
    }, 
    "fill_recipe": {
     "doc": "Name of recipe to be used in filler material stream requests.", 
     "index": 1, 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "fill_size": {
     "doc": "Size of filler material stream inventory.", 
     "index": 3, 
     "type": "double", 
     "units": "kg"
    }, 
    "fiss": {
     "capacity": "fiss_size", 
     "index": 9, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "fiss_commod_prefs": {
     "default": [], 
     "doc": "Fissile stream commodity request preferences for each of the given fissile commodities (same order). If unspecified, default is to use zero for all preferences.", 
     "index": 6, 
     "type": ["std::vector", "double"]
    }, 
    "fiss_commods": {
     "doc": "Ordered list of commodities on which to requesting fissile stream material.", 
     "index": 5, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "fiss_recipe": {
     "default": "", 
     "doc": "Name for recipe to be used in fissile stream requests. Empty string results in use of an empty dummy recipe.", 
     "index": 7, 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "fiss_size": {
     "doc": "Size of fissile material stream inventory.", 
     "index": 8, 
     "type": "double", 
     "units": "kg"
    }, 
    "outcommod": {
     "doc": "Commodity on which to offer/supply mixed fuel material.", 
     "index": 16, 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "spectrum": {
     "doc": "The type of cross-sections to use for composition property calculation. Use 'fission_spectrum_ave' for fast reactor compositions or 'thermal' for thermal reactors.", 
     "index": 15, 
     "type": "std::string"
    }, 
    "throughput": {
     "doc": "Maximum number of kg of fuel material that can be supplied per time step.", 
     "index": 17, 
     "type": "double", 
     "units": "kg"
    }, 
    "topup": {
     "capacity": "topup_size", 
     "index": 14, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "topup_commod": {
     "default": "", 
     "doc": "Commodity on which to request material for top-up stream. This MUST be set if 'topup_size > 0'.", 
     "index": 10, 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "topup_pref": {
     "default": 0, 
     "doc": "Top-up material stream request preference.", 
     "index": 12, 
     "type": "double"
    }, 
    "topup_recipe": {
     "default": "", 
     "doc": "Name of recipe to be used in top-up material stream requests. This MUST be set if 'topup_size > 0'.", 
     "index": 11, 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "topup_size": {
     "default": 0, 
     "doc": "Size of top-up material stream inventory.", 
     "index": 13, 
     "type": "double", 
     "units": "kg"
    }
   }
  }, 
  ":cycamore:GrowthRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A region that governs a scenario in which there is growth in demand for a commodity. ", 
   "entity": "region", 
   "name": "cycamore::GrowthRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {
    "commodity_name": {
     "doc": "name of the commodity experiencing a growth in demand", 
     "index": 0, 
     "tooltip": "commodity in demand", 
     "type": "std::string", 
     "uitype": "commodity"
    }, 
    "demand_params": {
     "doc": "parameters that define the behavior of the demand type function", 
     "index": 2, 
     "tooltip": "demand parameters", 
     "type": ["std::vector", "std::string"]
    }, 
    "demand_times": {
     "doc": "vector describing the length of times regarding the piecewise demand type", 
     "index": 3, 
     "tooltip": "demand times", 
     "type": ["std::vector", "int"]
    }, 
    "demand_types": {
     "doc": "mathematical description of demand growth (i.e., linear, exponential, piecewise)", 
     "index": 1, 
     "tooltip": "demand type", 
     "type": ["std::vector", "std::string"]
    }
   }
  }, 
  ":cycamore:ManagerInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::toolkit::AgentManaged", 
    "cyclus::toolkit::Builder", 
    "cyclus::toolkit::CommodityProducerManager"
   ], 
   "doc": "An institution that owns and operates a manually entered list of facilities in the input file", 
   "entity": "institution", 
   "name": "cycamore::ManagerInst", 
   "parents": [
    "cyclus::Institution", 
    "cyclus::toolkit::Builder", 
    "cyclus::toolkit::CommodityProducerManager"
   ], 
   "vars": {
    "prototypes": {
     "doc": "a facility to be managed by the institution", 
     "index": 0, 
     "tooltip": "facility prototypes", 
     "type": ["std::vector", "std::string"], 
     "uitype": ["none", "prototype"]
    }
   }
  }, 
  ":cycamore:Reactor": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader", 
    "cyclus::toolkit::AgentManaged", 
    "cyclus::toolkit::CommodityProducer"
   ], 
   "doc": "Reactor is a simple, general reactor based on static compositional transformations to model fuel burnup.  The user specifies a set of input fuels and corresponding burnt compositions that fuel is transformed to when it is discharged from the core.  No incremental transmutation takes place. Rather, at the end of an operational cycle, the batch being discharged from the core is instantaneously transmuted from its original fresh fuel composition into its spent fuel form.\n\nEach fuel is identified by a specific input commodity and has an associated input recipe (nuclide composition), output recipe, output commidity, and preference.  The preference identifies which input fuels are preferred when requesting.  Changes in these preferences can be specified as a function of time using the pref_change variables.  Changes in the input-output recipe compositions can also be specified as a function of time using the recipe_change variables.\n\nThe reactor treats fuel as individual assemblies that are never split, combined or otherwise treated in any non-discrete way.  Fuel is requested in full-or-nothing assembly sized quanta.  If real-world assembly modeling is unnecessary, parameters can be adjusted (e.g. n_assem_core, assem_size, n_assem_batch).  At the end of every cycle, a full batch is discharged from the core consisting of n_assem_batch assemblies of assem_size kg. The reactor also has a specifiable refueling time period following the end of each cycle at the end of which it will resume operation on the next cycle *if* it has enough fuel for a full core; otherwise it waits until it has enough fresh fuel assemblies.\n\nIn addition to its core, the reactor has an on-hand fresh fuel inventory and a spent fuel inventory whose capacities are specified by n_assem_fresh and n_assem_spent respectively.  Each time step the reactor will attempt to acquire enough fresh fuel to fill its fresh fuel inventory (and its core if the core isn't currently full).  If the fresh fuel inventory has zero capacity, fuel will be ordered just-in-time after the end of each operational cycle before the next begins.  If the spent fuel inventory becomes full, the reactor will halt operation at the end of the next cycle until there is more room.  Each time step, the reactor will try to trade away as much of its spent fuel inventory as possible.", 
   "entity": "facility", 
   "name": "cycamore::Reactor", 
   "niche": "reactor", 
   "parents": ["cyclus::Facility", "cyclus::toolkit::CommodityProducer"], 
   "vars": {
    "assem_size": {
     "doc": "Mass (kg) of a single assembly.", 
     "index": 3, 
     "type": "double", 
     "units": "kg"
    }, 
    "core": {
     "capacity": "n_assem_core * assem_size", 
     "index": 16, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "cycle_step": {
     "default": 0, 
     "doc": "Number of time steps since the start of the last cycle. Only set this if you know what you are doing", 
     "index": 9, 
     "type": "int", 
     "units": "time steps"
    }, 
    "cycle_time": {
     "doc": "The duration of a full operational cycle (excluding refueling time) in time steps.", 
     "index": 7, 
     "type": "int", 
     "units": "time steps"
    }, 
    "discharged": {
     "default": 0, 
     "doc": "This should NEVER be set manually.", 
     "index": 25, 
     "type": "bool"
    }, 
    "fresh": {
     "capacity": "n_assem_fresh * assem_size", 
     "index": 15, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "fuel_incommods": {
     "doc": "Ordered list of input commodities on which to requesting fuel.", 
     "index": 10, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "fuel_inrecipes": {
     "doc": "Fresh fuel recipes to request for each of the given fuel input commodities (same order).", 
     "index": 11, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "recipe"]
    }, 
    "fuel_outcommods": {
     "doc": "Output commodities on which to offer spent fuel originally received as each particular  input commodity (same order).", 
     "index": 13, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "outcommodity"]
    }, 
    "fuel_outrecipes": {
     "doc": "Spent fuel recipes corresponding to the given fuel input commodities (same order). Fuel received via a particular input commodity is transmuted to the recipe specified here after being burned during a cycle.", 
     "index": 12, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "recipe"]
    }, 
    "fuel_prefs": {
     "default": [], 
     "doc": "The preference for each type of fresh fuel requested corresponding to each input commodity (same order).  If no preferences are specified, zero is used for all fuel requests (default).", 
     "index": 14, 
     "type": ["std::vector", "double"]
    }, 
    "n_assem_batch": {
     "doc": "Number of assemblies that constitute a single batch.This is the number of assemblies discharged from the core fully burned each cycle.Batch size is equivalent to ``n_assem_batch / n_assem_core``.", 
     "index": 2, 
     "type": "int"
    }, 
    "n_assem_core": {
     "doc": "Number of assemblies that constitute a full core.", 
     "index": 4, 
     "type": "int"
    }, 
    "n_assem_fresh": {
     "default": 0, 
     "doc": "Number of fresh fuel assemblies to keep on-hand if possible.", 
     "index": 6, 
     "type": "int"
    }, 
    "n_assem_spent": {
     "default": 1000000000, 
     "doc": "Number of spent fuel assemblies that can be stored on-site before reactor operation stalls.", 
     "index": 5, 
     "type": "int"
    }, 
    "power_cap": {
     "default": 0, 
     "doc": "Amount of electrical power the facility produces when operating normally.", 
     "index": 0, 
     "type": "double", 
     "units": "MWe"
    }, 
    "power_name": {
     "default": "power", 
     "doc": "The name of the 'power' commodity used in conjunction with a deployment curve.", 
     "index": 1, 
     "type": "std::string"
    }, 
    "pref_change_commods": {
     "default": [], 
     "doc": "The input commodity for a particular fuel preference change. Same order as and direct correspondence to the specified preference change times.", 
     "index": 19, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "pref_change_times": {
     "default": [], 
     "doc": "A time step on which to change the request preference for a particular fresh fuel type.", 
     "index": 18, 
     "type": ["std::vector", "int"]
    }, 
    "pref_change_values": {
     "default": [], 
     "doc": "The new/changed request preference for a particular fresh fuel. Same order as and direct correspondence to the specified preference change times.", 
     "index": 20, 
     "type": ["std::vector", "double"]
    }, 
    "recipe_change_commods": {
     "default": [], 
     "doc": "The input commodity indicating fresh fuel for which recipes will be changed. Same order as and direct correspondence to the specified recipe change times.", 
     "index": 22, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "recipe_change_in": {
     "default": [], 
     "doc": "The new input recipe to use for this recipe change. Same order as and direct correspondence to the specified recipe change times.", 
     "index": 23, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "recipe"]
    }, 
    "recipe_change_out": {
     "default": [], 
     "doc": "The new output recipe to use for this recipe change. Same order as and direct correspondence to the specified recipe change times.", 
     "index": 24, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "recipe"]
    }, 
    "recipe_change_times": {
     "default": [], 
     "doc": "A time step on which to change the input-output recipe pair for a requested fresh fuel.", 
     "index": 21, 
     "type": ["std::vector", "int"]
    }, 
    "refuel_time": {
     "doc": "The duration of a full refueling period - the minimum time between a cycle end and the start of the next cycle.", 
     "index": 8, 
     "type": "int", 
     "units": "time steps"
    }, 
    "res_indexes": {
     "default": {}, 
     "doc": "This should NEVER be set manually.", 
     "index": 26, 
     "type": ["std::map", "int", "int"]
    }, 
    "spent": {
     "capacity": "n_assem_spent * assem_size", 
     "index": 17, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }
   }
  }, 
  ":cycamore:Separations": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "Separations processes feed material into one or more streams containing specific elements and/or nuclides.  It uses mass-based efficiencies.\n\nUser defined separations streams are specified as groups of component-efficiency pairs where 'component' means either a particular element or a particular nuclide.  Each component's paired efficiency represents the mass fraction of that component in the feed that is separated into that stream.  The efficiencies of a particular component across all streams must sum up to less than or equal to one.  If less than one, the remainining material is sent to a waste inventory and (potentially) traded away from there.\n\nThe facility receives material into a feed inventory that it processes with a specified throughput each time step.  Each output stream has a corresponding output inventory size/limit.  If the facility is unable to reduce its stocks by trading and hits this limit for any of its output streams, further processing/separations of feed material will halt until room is again available in the output streams.", 
   "entity": "facility", 
   "name": "cycamore::Separations", 
   "niche": "separations", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "feed": {
     "capacity": "feedbuf_size", 
     "index": 5, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "feed_commod_prefs": {
     "default": [], 
     "doc": "Feed commodity request preferences for each of the given feed commodities (same order). If unspecified, default is to use zero for all preferences.", 
     "index": 2, 
     "type": ["std::vector", "double"]
    }, 
    "feed_commods": {
     "doc": "Ordered list of commodities on which to request feed material to separate. Order only matters for matching up with feed commodity preferences if specified.", 
     "index": 1, 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "feed_recipe": {
     "default": "", 
     "doc": "Name for recipe to be used in feed requests. Empty string results in use of a dummy recipe.", 
     "index": 3, 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "feedbuf_size": {
     "doc": "Maximum amount of feed material to keep on hand.", 
     "index": 4, 
     "type": "double", 
     "units": "kg"
    }, 
    "leftover": {
     "capacity": "leftoverbuf_size", 
     "index": 8, 
     "type": ["cyclus::toolkit::ResBuf", "cyclus::Material"]
    }, 
    "leftover_commod": {
     "default": "default-waste-stream", 
     "doc": "Commodity on which to trade the leftover separated material stream. This MUST NOT be the same as any commodity used to define the other separations streams.", 
     "index": 7, 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "leftoverbuf_size": {
     "default": 1.000000000000000e+299, 
     "doc": "Maximum amount of leftover separated material (not included in any other stream) that can be stored. If full, the facility halts operation until space becomes available.", 
     "index": 6, 
     "type": "double", 
     "units": "kg"
    }, 
    "streams": "streams_", 
    "streams_": {
     "alias": [
      ["streams", "item"], 
      "commod", 
      ["info", "buf_size", [["efficiencies", "item"], "comp", "eff"]]
     ], 
     "doc": "Output streams for separations. Each stream must have a unique name identifying the commodity on which its material is traded, a max buffer capacity in kg (neg values indicate infinite size), and a set of component efficiencies. 'comp' is a component to be separated into the stream (e.g. U, Pu, etc.) and 'eff' is the mass fraction of the component that is separated from the feed into this output stream. If any stream buffer is full, the facility halts operation until space becomes available. The sum total of all component efficiencies across streams must be less than or equal to 1 (e.g. sum of U efficiencies for all streams must be <= 1).", 
     "index": 9, 
     "type": [
      "std::map", 
      "std::string", 
      ["std::pair", "double", ["std::map", "int", "double"]]
     ], 
     "uitype": [
      "oneormore", 
      "outcommodity", 
      ["pair", "double", ["oneormore", "nuclide", "double"]]
     ]
    }, 
    "throughput": {
     "doc": "Maximum quantity of feed material that can be processed per time step.", 
     "index": 0, 
     "type": "double", 
     "units": "kg"
    }
   }
  }, 
  ":cycamore:Sink": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": " A sink facility that accepts materials and products with a fixed\n throughput (per time step) capacity and a lifetime capacity defined by\n a total inventory size. The inventory size and throughput capacity\n both default to infinite. If a recipe is provided, it will request\n material with that recipe. Requests are made for any number of\n specified commodities.\n", 
   "entity": "facility", 
   "name": "cycamore::Sink", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "default": 1.000000000000000e+299, 
     "doc": "capacity the sink facility can accept at each time step", 
     "index": 1, 
     "tooltip": "sink capacity", 
     "type": "double"
    }, 
    "in_commods": {
     "doc": "commodities that the sink facility accepts", 
     "index": 0, 
     "tooltip": "input commodities", 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 4, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of sink facility", 
     "index": 3, 
     "tooltip": "sink maximum inventory size", 
     "type": "double"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "name of recipe to use for material requests, where the default (empty string) is to accept everything", 
     "index": 2, 
     "tooltip": "requested composition", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  ":cycamore:Source": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader", 
    "cyclus::toolkit::AgentManaged", 
    "cyclus::toolkit::CommodityProducer"
   ], 
   "doc": "This facility acts as a source of material with a fixed throughput (per\n time step) capacity and a lifetime capacity defined by a total inventory\n size.  It offers its material as a single commodity. If a composition\n recipe is specified, it provides that single material composition to\n requesters.  If unspecified, the source provides materials with the exact\n requested compositions.  The inventory size and throughput both default to\n infinite.  Supplies material results in corresponding decrease in\n inventory, and when the inventory size reaches zero, the source can provide\n no more material.\n", 
   "entity": "facility", 
   "name": "cycamore::Source", 
   "parents": ["cyclus::Facility", "cyclus::toolkit::CommodityProducer"], 
   "vars": {
    "inventory_size": {
     "default": 1.000000000000000e+299, 
     "doc": "Total amount of material this source has remaining. Every trade decreases this value by the supplied material quantity'. When it reaches zero, the source cannot provide any more material.", 
     "index": 3, 
     "type": "double", 
     "units": "kg"
    }, 
    "outcommod": {
     "doc": "Output commodity on which the source offers material.", 
     "index": 0, 
     "tooltip": "source output commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "outrecipe": {
     "default": "", 
     "doc": "Name of composition recipe that this source provides regardless of requested composition. If empty, source creates and provides whatever compositions are requested.", 
     "index": 1, 
     "tooltip": "name of material recipe to provide", 
     "type": "std::string", 
     "uitype": "recipe"
    }, 
    "throughput": {
     "default": 1.000000000000000e+299, 
     "doc": "amount of commodity that can be supplied at each time step", 
     "index": 2, 
     "tooltip": "per time step throughput", 
     "type": "double", 
     "units": "kg/(time step)"
    }
   }
  }, 
  "StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub region is provided as a skeleton for the design of new region agents.", 
   "entity": "region", 
   "name": "stubs::StubRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }, 
  "StubFacility/cyclus/StubInst:StubInst:StubInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub institution is provided as a skeleton for the design of new institution agents.", 
   "entity": "institution", 
   "name": "stubs::StubInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  "StubFacility:StubFacility:StubFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A stub facility is provided as a skeleton for the design of new facility agents.", 
   "entity": "facility", 
   "name": "stubs::StubFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {}
  }, 
  "agents:agents:KFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility designed for integration tests that both provides and consumes commodities. It changes its request and offer amounts based on a power law with respect to time.", 
   "entity": "facility", 
   "name": "cyclus::KFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "current_capacity": {
     "default": 0, 
     "doc": "number of output commodity units that can be supplied at the current time step (infinite capacity can be represented by a very large number", 
     "index": 5, 
     "tooltip": "current output capacity", 
     "type": "double"
    }, 
    "in_capacity": {
     "doc": "number of commodity units that can be taken at each time step (infinite capacity can be represented by a very large number", 
     "index": 3, 
     "tooltip": "input commodity capacity", 
     "type": "double"
    }, 
    "in_commod": {
     "doc": "commodity that the k-facility consumes", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "input commodity", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 7, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "k_factor_in": {
     "doc": "conversion factor that governs the behavior of the k-facility's input commodity capacity", 
     "index": 8, 
     "tooltip": "input k-factor", 
     "type": "double"
    }, 
    "k_factor_out": {
     "doc": "conversion factor that governs the behavior of the k-facility's output commodity capacity", 
     "index": 9, 
     "tooltip": "output k-factor", 
     "type": "double"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of the k-facility", 
     "index": 6, 
     "tooltip": "k-facility maximum inventory size", 
     "type": "double"
    }, 
    "out_capacity": {
     "doc": "number of commodity units that can be supplied at each time step (infinite capacity can be represented by a very large number", 
     "index": 4, 
     "tooltip": "output commodity capacity", 
     "type": "double"
    }, 
    "out_commod": {
     "doc": "commodity that the k-facility supplies", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "output commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "doc": "recipe name for the k-facility's in-commodity", 
     "index": 2, 
     "schematype": "token", 
     "shape": [50], 
     "tooltip": "in-commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "agents:agents:NullInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "An instition that owns facilities in the simulation but exhibits null behavior. No parameters are given when using the null institution.", 
   "entity": "institution", 
   "name": "cyclus::NullInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  "agents:agents:NullRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A region that owns the simulation's institutions but exhibits null behavior. No parameters are given when using the null region.", 
   "entity": "region", 
   "name": "cyclus::NullRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }, 
  "agents:agents:Predator": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents predators in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Predator", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of predator at beginning of simulation", 
     "index": 7, 
     "tooltip": "predator age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 0, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 11, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "commod": {
     "doc": "commodity that the predator supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "predator commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "consumed": {
     "default": 0, 
     "doc": "how many units of prey consumed per time step", 
     "index": 12, 
     "tooltip": "prey consumed", 
     "type": "double"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether predator is currently dead", 
     "index": 9, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "full": {
     "default": 1, 
     "doc": "how many units of prey a predator consumes until it is satisfied", 
     "index": 2, 
     "tooltip": "feast size", 
     "type": "double"
    }, 
    "hunt_cap": {
     "default": 1, 
     "doc": "how many units of prey a predator can catch during a hunt", 
     "index": 3, 
     "tooltip": "hunting yield", 
     "type": "double"
    }, 
    "hunt_factor": {
     "default": 0, 
     "doc": "whether or not to base hunting success on relative predator/prey populations", 
     "index": 10, 
     "tooltip": "hunting success factor", 
     "type": "bool"
    }, 
    "hunt_freq": {
     "default": 1, 
     "doc": "how often a predator needs to hunt", 
     "index": 4, 
     "tooltip": "hunting frequency", 
     "type": "int"
    }, 
    "lifespan": {
     "default": 1, 
     "doc": "how long a predator lives", 
     "index": 8, 
     "tooltip": "predator lifespan", 
     "type": "int"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of predator children born at each birthing instance", 
     "index": 6, 
     "tooltip": "number of children", 
     "type": "double"
    }, 
    "prey": {
     "doc": "prey that the predator hunts", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "predator's prey", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "success": {
     "default": 1, 
     "doc": "fraction of hunting success on a scale from 0 to 1", 
     "index": 5, 
     "tooltip": "hunting success fraction", 
     "type": "double"
    }
   }
  }, 
  "agents:agents:Prey": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents prey in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Prey", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of prey at start of simulation", 
     "index": 3, 
     "tooltip": "prey age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 1, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 5, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "birth_freq": {
     "default": 1, 
     "doc": "number of time steps between birth of children", 
     "index": 1, 
     "tooltip": "birth frequency", 
     "type": "int"
    }, 
    "commod": {
     "index": 0, 
     "schematype": "token", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether prey is currently dead", 
     "index": 4, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of children born at each birthing instance", 
     "index": 2, 
     "tooltip": "number of children", 
     "type": "int"
    }
   }
  }, 
  "agents:agents:Sink": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation sink facility that accepts specified amounts of commodities from other agents", 
   "entity": "facility", 
   "name": "cyclus::Sink", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "capacity the sink facility can accept at each time step", 
     "index": 2, 
     "tooltip": "sink capacity", 
     "type": "double"
    }, 
    "in_commods": {
     "doc": "commodities that the sink facility accepts", 
     "index": 1, 
     "tooltip": "input commodities for the sink", 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 4, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of sink facility", 
     "index": 3, 
     "tooltip": "sink maximum inventory size", 
     "type": "double"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Name of recipe to request.If empty, sink requests material no particular composition.", 
     "index": 0, 
     "tooltip": "input/request recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "agents:agents:Source": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation source facility that provides a commodity with a given capacity", 
   "entity": "facility", 
   "name": "cyclus::Source", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "amount of commodity that can be supplied at each time step", 
     "index": 2, 
     "tooltip": "source capacity", 
     "type": "double"
    }, 
    "commod": {
     "doc": "commodity that the source facility supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "source commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Recipe name for source facility's commodity.If empty, source supplies material with requested compositions.", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "build/lib/cyclus/StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub region is provided as a skeleton for the design of new region agents.", 
   "entity": "region", 
   "name": "stubs::StubRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }, 
  "build/lib/cyclus/StubFacility/cyclus/StubInst:StubInst:StubInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub institution is provided as a skeleton for the design of new institution agents.", 
   "entity": "institution", 
   "name": "stubs::StubInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  "build/lib/cyclus/StubFacility:StubFacility:StubFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A stub facility is provided as a skeleton for the design of new facility agents.", 
   "entity": "facility", 
   "name": "stubs::StubFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {}
  }, 
  "build/lib/cyclus/agents:agents:KFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility designed for integration tests that both provides and consumes commodities. It changes its request and offer amounts based on a power law with respect to time.", 
   "entity": "facility", 
   "name": "cyclus::KFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "current_capacity": {
     "default": 0, 
     "doc": "number of output commodity units that can be supplied at the current time step (infinite capacity can be represented by a very large number", 
     "index": 5, 
     "tooltip": "current output capacity", 
     "type": "double"
    }, 
    "in_capacity": {
     "doc": "number of commodity units that can be taken at each time step (infinite capacity can be represented by a very large number", 
     "index": 3, 
     "tooltip": "input commodity capacity", 
     "type": "double"
    }, 
    "in_commod": {
     "doc": "commodity that the k-facility consumes", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "input commodity", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 7, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "k_factor_in": {
     "doc": "conversion factor that governs the behavior of the k-facility's input commodity capacity", 
     "index": 8, 
     "tooltip": "input k-factor", 
     "type": "double"
    }, 
    "k_factor_out": {
     "doc": "conversion factor that governs the behavior of the k-facility's output commodity capacity", 
     "index": 9, 
     "tooltip": "output k-factor", 
     "type": "double"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of the k-facility", 
     "index": 6, 
     "tooltip": "k-facility maximum inventory size", 
     "type": "double"
    }, 
    "out_capacity": {
     "doc": "number of commodity units that can be supplied at each time step (infinite capacity can be represented by a very large number", 
     "index": 4, 
     "tooltip": "output commodity capacity", 
     "type": "double"
    }, 
    "out_commod": {
     "doc": "commodity that the k-facility supplies", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "output commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "doc": "recipe name for the k-facility's in-commodity", 
     "index": 2, 
     "schematype": "token", 
     "shape": [50], 
     "tooltip": "in-commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "build/lib/cyclus/agents:agents:NullInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "An instition that owns facilities in the simulation but exhibits null behavior. No parameters are given when using the null institution.", 
   "entity": "institution", 
   "name": "cyclus::NullInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  "build/lib/cyclus/agents:agents:NullRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A region that owns the simulation's institutions but exhibits null behavior. No parameters are given when using the null region.", 
   "entity": "region", 
   "name": "cyclus::NullRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }, 
  "build/lib/cyclus/agents:agents:Predator": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents predators in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Predator", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of predator at beginning of simulation", 
     "index": 7, 
     "tooltip": "predator age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 0, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 11, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "commod": {
     "doc": "commodity that the predator supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "predator commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "consumed": {
     "default": 0, 
     "doc": "how many units of prey consumed per time step", 
     "index": 12, 
     "tooltip": "prey consumed", 
     "type": "double"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether predator is currently dead", 
     "index": 9, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "full": {
     "default": 1, 
     "doc": "how many units of prey a predator consumes until it is satisfied", 
     "index": 2, 
     "tooltip": "feast size", 
     "type": "double"
    }, 
    "hunt_cap": {
     "default": 1, 
     "doc": "how many units of prey a predator can catch during a hunt", 
     "index": 3, 
     "tooltip": "hunting yield", 
     "type": "double"
    }, 
    "hunt_factor": {
     "default": 0, 
     "doc": "whether or not to base hunting success on relative predator/prey populations", 
     "index": 10, 
     "tooltip": "hunting success factor", 
     "type": "bool"
    }, 
    "hunt_freq": {
     "default": 1, 
     "doc": "how often a predator needs to hunt", 
     "index": 4, 
     "tooltip": "hunting frequency", 
     "type": "int"
    }, 
    "lifespan": {
     "default": 1, 
     "doc": "how long a predator lives", 
     "index": 8, 
     "tooltip": "predator lifespan", 
     "type": "int"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of predator children born at each birthing instance", 
     "index": 6, 
     "tooltip": "number of children", 
     "type": "double"
    }, 
    "prey": {
     "doc": "prey that the predator hunts", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "predator's prey", 
     "type": "std::string", 
     "uitype": "incommodity"
    }, 
    "success": {
     "default": 1, 
     "doc": "fraction of hunting success on a scale from 0 to 1", 
     "index": 5, 
     "tooltip": "hunting success fraction", 
     "type": "double"
    }
   }
  }, 
  "build/lib/cyclus/agents:agents:Prey": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A facility that represents prey in the Lotka-Volterra integration tests", 
   "entity": "facility", 
   "name": "cyclus::Prey", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "age": {
     "default": 0, 
     "doc": "age of prey at start of simulation", 
     "index": 3, 
     "tooltip": "prey age", 
     "type": "int"
    }, 
    "birth_and_death": {
     "default": 1, 
     "doc": "whether or not simultaneous birth and and death are allowed (i.e., can a facility give birth and die in the same time step?)", 
     "index": 5, 
     "tooltip": "simultaneous birth and death?", 
     "type": "bool"
    }, 
    "birth_freq": {
     "default": 1, 
     "doc": "number of time steps between birth of children", 
     "index": 1, 
     "tooltip": "birth frequency", 
     "type": "int"
    }, 
    "commod": {
     "index": 0, 
     "schematype": "token", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "dead": {
     "default": 0, 
     "doc": "flag for whether prey is currently dead", 
     "index": 4, 
     "tooltip": "dead?", 
     "type": "bool"
    }, 
    "nchildren": {
     "default": 1, 
     "doc": "number of children born at each birthing instance", 
     "index": 2, 
     "tooltip": "number of children", 
     "type": "int"
    }
   }
  }, 
  "build/lib/cyclus/agents:agents:Sink": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation sink facility that accepts specified amounts of commodities from other agents", 
   "entity": "facility", 
   "name": "cyclus::Sink", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "capacity the sink facility can accept at each time step", 
     "index": 2, 
     "tooltip": "sink capacity", 
     "type": "double"
    }, 
    "in_commods": {
     "doc": "commodities that the sink facility accepts", 
     "index": 1, 
     "tooltip": "input commodities for the sink", 
     "type": ["std::vector", "std::string"], 
     "uitype": ["oneormore", "incommodity"]
    }, 
    "inventory": {
     "capacity": "max_inv_size", 
     "index": 4, 
     "type": "cyclus::toolkit::ResourceBuff"
    }, 
    "max_inv_size": {
     "default": 1.000000000000000e+299, 
     "doc": "total maximum inventory size of sink facility", 
     "index": 3, 
     "tooltip": "sink maximum inventory size", 
     "type": "double"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Name of recipe to request.If empty, sink requests material no particular composition.", 
     "index": 0, 
     "tooltip": "input/request recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "build/lib/cyclus/agents:agents:Source": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A minimum implementation source facility that provides a commodity with a given capacity", 
   "entity": "facility", 
   "name": "cyclus::Source", 
   "parents": ["cyclus::Facility"], 
   "vars": {
    "capacity": {
     "doc": "amount of commodity that can be supplied at each time step", 
     "index": 2, 
     "tooltip": "source capacity", 
     "type": "double"
    }, 
    "commod": {
     "doc": "commodity that the source facility supplies", 
     "index": 0, 
     "schematype": "token", 
     "tooltip": "source commodity", 
     "type": "std::string", 
     "uitype": "outcommodity"
    }, 
    "recipe_name": {
     "default": "", 
     "doc": "Recipe name for source facility's commodity.If empty, source supplies material with requested compositions.", 
     "index": 1, 
     "schematype": "token", 
     "tooltip": "commodity recipe name", 
     "type": "std::string", 
     "uitype": "recipe"
    }
   }
  }, 
  "stubs:StubFacility:StubFacility": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Facility", 
    "cyclus::Ider", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener", 
    "cyclus::Trader"
   ], 
   "doc": "A stub facility is provided as a skeleton for the design of new facility agents.", 
   "entity": "facility", 
   "name": "stubs::StubFacility", 
   "parents": ["cyclus::Facility"], 
   "vars": {}
  }, 
  "stubs:StubInst:StubInst": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Institution", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub institution is provided as a skeleton for the design of new institution agents.", 
   "entity": "institution", 
   "name": "stubs::StubInst", 
   "parents": ["cyclus::Institution"], 
   "vars": {}
  }, 
  "stubs:StubRegion:StubRegion": {
   "all_parents": [
    "cyclus::Agent", 
    "cyclus::Ider", 
    "cyclus::Region", 
    "cyclus::StateWrangler", 
    "cyclus::TimeListener"
   ], 
   "doc": "A stub region is provided as a skeleton for the design of new region agents.", 
   "entity": "region", 
   "name": "stubs::StubRegion", 
   "parents": ["cyclus::Region"], 
   "vars": {}
  }
 }, 
 "schema": {
  ":agents:KFacility": "<interleave>\n    <element name=\"in_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"out_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"recipe_name\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"in_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"out_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"current_capacity\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <element name=\"k_factor_in\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"k_factor_out\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  ":agents:NullInst": "<text/>", 
  ":agents:NullRegion": "<text/>", 
  ":agents:Predator": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"prey\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"full\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_cap\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"success\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"lifespan\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_factor\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"consumed\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  ":agents:Prey": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"birth_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  ":agents:Sink": "<interleave>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"in_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  ":agents:Source": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"token\"/>\n        </element>\n    </optional>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  ":cycamore:DeployInst": "<interleave>\n    <element name=\"prototypes\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"build_times\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"int\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"n_build\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"int\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <optional>\n        <element name=\"lifetimes\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"int\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n</interleave>\n", 
  ":cycamore:Enrichment": "<interleave>\n    <element name=\"feed_commod\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"product_commod\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"feed_recipe\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"tails_commod\">\n        <data type=\"string\"/>\n    </element>\n    <optional>\n        <element name=\"tails_assay\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"swu_capacity\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_feed_inventory\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_enrich\">\n            <data type=\"double\">\n                <param name=\"minInclusive\">0</param>\n                <param name=\"maxInclusive\">1</param>\n            </data>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"initial_feed\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"order_prefs\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  ":cycamore:FuelFab": "<interleave>\n    <element name=\"fill_commod\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"fill_recipe\">\n        <data type=\"string\"/>\n    </element>\n    <optional>\n        <element name=\"fill_pref\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <element name=\"fill_size\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"fiss_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <optional>\n        <element name=\"fiss_commod_prefs\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"double\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"fiss_recipe\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"fiss_size\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"topup_commod\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"topup_recipe\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"topup_pref\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"topup_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <element name=\"spectrum\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"outcommod\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"throughput\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  ":cycamore:GrowthRegion": "<interleave>\n    <element name=\"commodity_name\">\n        <data type=\"string\"/>\n    </element>\n    <element name=\"demand_types\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"demand_params\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"demand_times\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"int\"/>\n            </element>\n        </oneOrMore>\n    </element>\n</interleave>\n", 
  ":cycamore:ManagerInst": "<interleave>\n    <element name=\"prototypes\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n</interleave>\n", 
  ":cycamore:Reactor": "<interleave>\n    <optional>\n        <element name=\"power_cap\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"power_name\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"n_assem_batch\">\n        <data type=\"int\"/>\n    </element>\n    <element name=\"assem_size\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"n_assem_core\">\n        <data type=\"int\"/>\n    </element>\n    <optional>\n        <element name=\"n_assem_spent\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"n_assem_fresh\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <element name=\"cycle_time\">\n        <data type=\"int\"/>\n    </element>\n    <element name=\"refuel_time\">\n        <data type=\"int\"/>\n    </element>\n    <optional>\n        <element name=\"cycle_step\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <element name=\"fuel_incommods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"fuel_inrecipes\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"fuel_outrecipes\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"fuel_outcommods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <optional>\n        <element name=\"fuel_prefs\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"double\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"pref_change_times\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"int\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"pref_change_commods\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"string\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"pref_change_values\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"double\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"recipe_change_times\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"int\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"recipe_change_commods\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"string\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"recipe_change_in\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"string\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"recipe_change_out\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"string\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"discharged\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"res_indexes\">\n            <oneOrMore>\n                <element name=\"item\">\n                    <interleave>\n                        <element name=\"key\">\n                            <data type=\"int\"/>\n                        </element>\n                        <element name=\"val\">\n                            <data type=\"int\"/>\n                        </element>\n                    </interleave>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n</interleave>\n", 
  ":cycamore:Separations": "<interleave>\n    <element name=\"throughput\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"feed_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <optional>\n        <element name=\"feed_commod_prefs\">\n            <oneOrMore>\n                <element name=\"val\">\n                    <data type=\"double\"/>\n                </element>\n            </oneOrMore>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"feed_recipe\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"feedbuf_size\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"leftoverbuf_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"leftover_commod\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"streams\">\n        <oneOrMore>\n            <element name=\"item\">\n                <interleave>\n                    <element name=\"commod\">\n                        <data type=\"string\"/>\n                    </element>\n                    <element name=\"info\">\n                        <interleave>\n                            <element name=\"buf_size\">\n                                <data type=\"double\"/>\n                            </element>\n                            <element name=\"efficiencies\">\n                                <oneOrMore>\n                                    <element name=\"item\">\n                                        <interleave>\n                                            <element name=\"comp\">\n                                                <data type=\"string\"/>\n                                            </element>\n                                            <element name=\"eff\">\n                                                <data type=\"double\"/>\n                                            </element>\n                                        </interleave>\n                                    </element>\n                                </oneOrMore>\n                            </element>\n                        </interleave>\n                    </element>\n                </interleave>\n            </element>\n        </oneOrMore>\n    </element>\n</interleave>\n", 
  ":cycamore:Sink": "<interleave>\n    <element name=\"in_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <optional>\n        <element name=\"capacity\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  ":cycamore:Source": "<interleave>\n    <element name=\"outcommod\">\n        <data type=\"string\"/>\n    </element>\n    <optional>\n        <element name=\"outrecipe\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"throughput\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"inventory_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion": "<text/>", 
  "StubFacility/cyclus/StubInst:StubInst:StubInst": "<text/>", 
  "StubFacility:StubFacility:StubFacility": "<text/>", 
  "agents:agents:KFacility": "<interleave>\n    <element name=\"in_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"out_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"recipe_name\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"in_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"out_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"current_capacity\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <element name=\"k_factor_in\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"k_factor_out\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  "agents:agents:NullInst": "<text/>", 
  "agents:agents:NullRegion": "<text/>", 
  "agents:agents:Predator": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"prey\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"full\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_cap\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"success\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"lifespan\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_factor\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"consumed\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "agents:agents:Prey": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"birth_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "agents:agents:Sink": "<interleave>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"in_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "agents:agents:Source": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"token\"/>\n        </element>\n    </optional>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  "build/lib/cyclus/StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion": "<text/>", 
  "build/lib/cyclus/StubFacility/cyclus/StubInst:StubInst:StubInst": "<text/>", 
  "build/lib/cyclus/StubFacility:StubFacility:StubFacility": "<text/>", 
  "build/lib/cyclus/agents:agents:KFacility": "<interleave>\n    <element name=\"in_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"out_commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"recipe_name\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"in_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"out_capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"current_capacity\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <element name=\"k_factor_in\">\n        <data type=\"double\"/>\n    </element>\n    <element name=\"k_factor_out\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  "build/lib/cyclus/agents:agents:NullInst": "<text/>", 
  "build/lib/cyclus/agents:agents:NullRegion": "<text/>", 
  "build/lib/cyclus/agents:agents:Predator": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <element name=\"prey\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"full\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_cap\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"success\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"lifespan\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"hunt_factor\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"consumed\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "build/lib/cyclus/agents:agents:Prey": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"birth_freq\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"nchildren\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"age\">\n            <data type=\"int\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"dead\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n    <optional>\n        <element name=\"birth_and_death\">\n            <data type=\"boolean\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "build/lib/cyclus/agents:agents:Sink": "<interleave>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"string\"/>\n        </element>\n    </optional>\n    <element name=\"in_commods\">\n        <oneOrMore>\n            <element name=\"val\">\n                <data type=\"string\"/>\n            </element>\n        </oneOrMore>\n    </element>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n    <optional>\n        <element name=\"max_inv_size\">\n            <data type=\"double\"/>\n        </element>\n    </optional>\n</interleave>\n", 
  "build/lib/cyclus/agents:agents:Source": "<interleave>\n    <element name=\"commod\">\n        <data type=\"token\"/>\n    </element>\n    <optional>\n        <element name=\"recipe_name\">\n            <data type=\"token\"/>\n        </element>\n    </optional>\n    <element name=\"capacity\">\n        <data type=\"double\"/>\n    </element>\n</interleave>\n", 
  "stubs:StubFacility:StubFacility": "<text/>", 
  "stubs:StubInst:StubInst": "<text/>", 
  "stubs:StubRegion:StubRegion": "<text/>"
 }, 
 "specs": [
  ":agents:KFacility", 
  ":agents:NullInst", 
  ":agents:NullRegion", 
  ":agents:Predator", 
  ":agents:Prey", 
  ":agents:Sink", 
  ":agents:Source", 
  ":cycamore:DeployInst", 
  ":cycamore:Enrichment", 
  ":cycamore:FuelFab", 
  ":cycamore:GrowthRegion", 
  ":cycamore:ManagerInst", 
  ":cycamore:Reactor", 
  ":cycamore:Separations", 
  ":cycamore:Sink", 
  ":cycamore:Source", 
  "StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion", 
  "StubFacility/cyclus/StubInst:StubInst:StubInst", 
  "StubFacility:StubFacility:StubFacility", 
  "agents:agents:KFacility", 
  "agents:agents:NullInst", 
  "agents:agents:NullRegion", 
  "agents:agents:Predator", 
  "agents:agents:Prey", 
  "agents:agents:Sink", 
  "agents:agents:Source", 
  "build/lib/cyclus/StubFacility/cyclus/StubInst/cyclus/StubRegion:StubRegion:StubRegion", 
  "build/lib/cyclus/StubFacility/cyclus/StubInst:StubInst:StubInst", 
  "build/lib/cyclus/StubFacility:StubFacility:StubFacility", 
  "build/lib/cyclus/agents:agents:KFacility", 
  "build/lib/cyclus/agents:agents:NullInst", 
  "build/lib/cyclus/agents:agents:NullRegion", 
  "build/lib/cyclus/agents:agents:Predator", 
  "build/lib/cyclus/agents:agents:Prey", 
  "build/lib/cyclus/agents:agents:Sink", 
  "build/lib/cyclus/agents:agents:Source", 
  "stubs:StubFacility:StubFacility", 
  "stubs:StubInst:StubInst", 
  "stubs:StubRegion:StubRegion"
 ]
}
